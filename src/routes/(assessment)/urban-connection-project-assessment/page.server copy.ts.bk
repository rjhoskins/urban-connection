import { demographicsQuestionsData } from '$lib/constants.js';
import { AssessmentTokenInviteSchema } from '$lib/schema';
import {
	addDemographicsData,
	addQuestionsData,
	generateQuestionnaire,
	getAssessmentDataByAssessmentId,
	getDemographicsDataByAssessmentId,
	setAssessmentStatus,
	createAssessment,
	getSchoolById,
	getAssessmenIdByCodeAndParticpantEmail
} from '$lib/server/queries';
import { createMixedBagAssessmentAndDemographics } from '$lib/types/assessment.js';
import {
	applyAssessmentResponsesToQuestionsAndGetCurrentPositions,,
	handleLogFlashReturnFormError,
	transformAssessmentQuestionsResponses
} from '$lib/utils.js';
import { error, fail, redirect, type RequestEvent } from '@sveltejs/kit';
import { is } from 'drizzle-orm';

import { setFlash } from 'sveltekit-flash-message/server';

// http://localhost:5173/urban-connection-project-assessment?assessmentToken=VHpsV1VPYlpwMDhSTWl4NHwyMXwzMzVBQnA=

export async function load({ params, url, cookies }) {
	console.log('page load ====> ');
	const assessmentToken = await url.searchParams.get('assessmentToken');
	const decodedeAssessmentToken = decodeAssessmentInviteToken(assessmentToken as string);
	console.log('decodedeAssessmentToken ====> ', decodedeAssessmentToken);

	//no participantEmail data validation
	const { sentBy, schoolId, code, participantEmail } = decodedeAssessmentToken;
	const tokenParseResSansParticipantEmailRes = AssessmentTokenInviteSchema.safeParse({
		sentBy,
		schoolId,
		code,
		participantEmail
	});

	if (!tokenParseResSansParticipantEmailRes.success) {
		console.log(
			'tokenParseResSansParticipantEmailRes error => ',
			tokenParseResSansParticipantEmailRes.error
		);
		console.log('here tokenParseResSansParticipantEmail ====> ', {
			assessmentToken,
			schoolId,
			code,
			participantEmail,
			tokenParseResSansParticipantEmailRes
		});
		setFlash({ type: 'error', message: 'load malformed token' }, cookies);
		throw redirect(303, '/');
	}

	//token well formed - school & token good?
	let isvalidSchool = await isValidSchool(schoolId, cookies);
	if (!isvalidSchool || code.length !== 6) {
		console.log('invalid school OR TOKEN ====> ');
		setFlash({ type: 'error', message: 'malformed token' }, cookies);
		throw redirect(307, '/');
	}

	// vars
	let assessmentQuestions = await generateQuestionnaire();
	let lastAnsweredQuestionIdInDomain;
	let lastAnsweredQuestionIdInSubdomain;
	let currAssessmentData;
	let currDemgraphicsData;

	if (participantEmail === 'undefined') {
		//initial load - no email yet
		console.log('NO participantEmail ====> ');
		assessmentQuestions = [demographicsQuestionsData, ...assessmentQuestions];
		return {
			isNewParticipant: true,
			currDemgraphicsData,
			currAssessmentData,
			assessmentToken,
			assessmentQuestions,
			lastAnsweredQuestionIdInDomain,
			lastAnsweredQuestionIdInSubdomain
		};
	}

	//has participantEmail - proceed with validation & such
	const tokenParseResWithParticipantEmail = AssessmentTokenInviteSchema.safeParse({
		sentBy,
		schoolId,
		code,
		participantEmail
	});
	if (!tokenParseResWithParticipantEmail.success) {
		console.log('here participantEmail ====> ', { assessmentToken, schoolId, code });
		setFlash({ type: 'error', message: 'load malformed token' }, cookies);
		// throw redirect(401, '/');
	}

	//token valid - proceed with checking assessment status to load current position
	// const currAssessment = await getAssessmenIdByCodeAndParticpantEmail({
	// 	code,
	// 	participantEmail
	// });

	// if (!currAssessment) {
	// 	console.log('NOOOO currAssessment ====> ');
	// 	assessmentQuestions = [demographicsQuestionsData, ...assessmentQuestions];
	// } else if (currAssessment && currAssessment?.status === 'started') {
	// 	//gets intense here ===>
	// 	console.log('currAssessment STARTED ====> ', currAssessment);
	// 	currDemgraphicsData = currAssessment?.id
	// 		? await getDemographicsDataByAssessmentId(currAssessment?.id!)
	// 		: null;
	// 	console.log('currDemgraphicsData ====> ', currDemgraphicsData);
	// 	currAssessmentData = currAssessment?.id
	// 		? await getAssessmentDataByAssessmentId(currAssessment?.id!)
	// 		: null;

		const {
			assessmentQuestionsCopy,
			lastCompletedDomainId: lastDomain,
			lastCompletedSubDomainId: lastSubdomain
		} = applyAssessmentResponsesToQuestionsAndGetCurrentPositions({
			assessmentQuestions,
			currDemgraphicsData,
			currAssessmentData: currAssessmentData!
		});
		assessmentQuestions = assessmentQuestionsCopy;
		lastAnsweredQuestionIdInDomain = lastDomain;
		lastAnsweredQuestionIdInSubdomain = lastSubdomain;
		assessmentQuestions = [demographicsQuestionsData, ...assessmentQuestions];
	} else if (currAssessment && currAssessment?.status === 'completed') {
		console.log('currAssessment COMPLETED ====> ', currAssessment);
		setFlash({ type: 'error', message: 'Assessment already completed' }, cookies);
		throw redirect(303, '/thank-you');
	}

	// console.log('THIS ====> ', {
	// 	// currDemgraphicsData,
	// 	// currAssessmentData,
	// 	// assessmentToken,
	// 	// assessmentQuestions: assessmentQuestions.slice(0, 10)
	// 	// lastAnsweredQuestionIdInDomain,
	// 	// lastAnsweredQuestionIdInSubdomain
	// });

	return {
		currDemgraphicsData,
		currAssessmentData,
		assessmentToken,
		assessmentQuestions,
		lastAnsweredQuestionIdInDomain,
		lastAnsweredQuestionIdInSubdomain
	};
}

export const actions = {
	default: async (event: RequestEvent) => {
		let hasError = false;
		let UnexpectedErrorMsg = '';
		const formData = await event.request.formData();
		const data = Object.fromEntries(formData);
		console.log('SUBMIT data ====> ', data);
		const assessmentToken = data.assessmentToken;

		let newDemographicsData = {};

		if (assessmentToken !== event.url.searchParams.get('assessmentToken')) {
			return fail(400, { message: 'some trickey is afoot' });
		}
		const { sentBy, schoolId, code, participantEmail } = decodeAssessmentInviteToken(
			assessmentToken as string
		);

		console.log('actions decodedeAssessmentToken A ====> ', {
			sentBy,
			schoolId,
			code,
			participantEmail
		});
		const schoolIsValid = await isValidSchool(schoolId, event.cookies);

		if (!schoolIsValid) {
			return fail(400, {
				message: 'Issue with link, contact your administrator or try again later'
			});
		}

		const emailToUse = data.email ?? participantEmail; // participantEmail COMING FROM UPDATED TOKEN AFTER FIRST DEMO SUBMIT OR WITH DEMO INFO
		// console.log('emailz => ', { participantEmail, dataEmail: data.email }, emailToUse);
		//every request so data is good
		// return error(500, { message: 'test error handling' }); // --- IGNORE ---
		const currAssessment = await createOrFindAssessmentByEmail({
			participantEmail: emailToUse as string,
			schoolId,
			sentBy,
			tokenCode: code,
			participantName: String(data.name) || 'No Name Provided',
			event
		});
		console.log('currAssessment after createOrFindAssessmentByEmail ====> ', currAssessment);

		try {
			if (data.isDemographics) {
				console.log('DEMO data ====> ', data);
				const isValidDemographics = isValidDemographicsData({
					data,
					schoolId,
					sentBy,
					code
				});
				if (!isValidDemographics) return fail(400, { message: 'Invalid demographics data' });

				if (!currAssessment) return fail(400, { message: 'Assessment not found' });

				//add demographics data
				newDemographicsData = {
					yearsTeaching: parseInt(String(data.yearsTeaching))!,
					schoolId,
					assessmentId: currAssessment.id,
					educationLevel: String(data.educationLevel)
				};
				await addDemographicsData(newDemographicsData); // default status to 'started' on demographics submission

				const demographicsReturnData = {
					currAssessmentId: currAssessment.id,
					// tokenWithEmail: createAssessmentInviteToken({
					// 	sentBy,
					// 	schoolId,
					// 	code,
					// 	participantEmail: String(data.email)
					// }),
					currAssessmentData: await getAssessmentDataByAssessmentId(currAssessment.id),
					currDemographicsData: newDemographicsData
				};

				//JOB DONE  demographics wise. redirect with complete token and check that henceforth
				return { ...demographicsReturnData };
			} else {
				// assessment questions
				console.log('QUESTIONS data ====> ', data);
				console.log('currAssessment =>  ', currAssessment);

				if (!currAssessment) {
					setFlash({ type: 'error', message: 'Assessment not found' }, event.cookies);
					throw redirect(400, '/');
				}
				const transformedAssessmentQuestionsResponses = transformAssessmentQuestionsResponses({
					...data,
					assessmentId: currAssessment.id
				});
				// console.log(
				// 	'transformedAssessmentQuestionsResponses data ====> ',
				// 	transformedAssessmentQuestionsResponses
				// );

				if (!transformedAssessmentQuestionsResponses.length) {
					setFlash({ type: 'error', message: 'No assessment data to save' }, event.cookies);
					throw redirect(400, '/');
				}

				await addQuestionsData(transformedAssessmentQuestionsResponses);

				if (data.isLastQuestion) {
					setAssessmentStatus({
						assessmentId: currAssessment.id,
						status: 'completed'
					});
				}
			}
		} catch (error) {
			hasError = true;
			const errorMessage = error instanceof Error ? error.message : JSON.stringify(error);
			UnexpectedErrorMsg = 'SERVER Unexpected error: ' + errorMessage;
			console.log('error => ', UnexpectedErrorMsg);
			setFlash({ type: 'error', message: 'malformed token' + UnexpectedErrorMsg }, event.cookies);
			return redirect(303, '/');
			// return { success: false, error: UnexpectedErrorMsg };
		}

		if (data.isDemographics && !hasError && !data.isLastQuestion) {
			console.log('isDemographics data ====> ', data);
			if (data.name && data.email) {
				setFlash({ type: 'success', message: 'Demographics Completed, Thank you!' }, event.cookies);
				return { success: true, isDemographics: true };
			}
		}
		if (data.isLastQuestion && !hasError) {
			console.log('isLastQuestion data ====> ', data);
			setFlash({ type: 'success', message: 'Assessment Completed, Thank you!' }, event.cookies);
			return redirect(303, '/thank-you');
		}
	}
};

async function isValidSchool(schoolId: number, cookies: any) {
	let isValidSchool = false;
	try {
		const school = await getSchoolById(schoolId);
		if (!school) {
			setFlash({ type: 'error', message: 'malformed token, invalid school' }, cookies);
			throw redirect(401, '/');
		}
		isValidSchool = true;
	} catch (error) {
		setFlash({ type: 'error', message: 'encountered an error' }, cookies);
		throw redirect(401, '/');
	}
	return isValidSchool;
}

async function createOrFindAssessmentByEmail({
	participantName,
	participantEmail,
	schoolId,
	sentBy,
	tokenCode
}: {
	participantEmail: string;
	schoolId: number;
	sentBy: string;
	tokenCode: string;
	participantName: string;
	event?: RequestEvent;
}): Promise<{ id: number; status: 'sent' | 'started' | 'completed' | null } | null> {
	console.log('PRE createOrFindAssessmentByEmail func ====> ', {
		participantEmail,
		schoolId,
		sentBy,
		tokenCode
	});
	//quick data check
	if (!participantEmail) throw new Error('Participant email is required');

	let assessment;

	try {
		let newAssessment;
		assessment = await getAssessmenIdByCodeAndParticpantEmail({
			code: tokenCode,
			participantEmail
		});

		if (!assessment) {
			newAssessment = await createAssessment({
				participantName,
				participantEmail,
				schoolId,
				sentBy,
				tokenCode
			});
			console.log('newAssessment ====> ', newAssessment);
			assessment = newAssessment;
		}
		if (!assessment) return error('Failed to find or create assessment ');

		return {
			id: assessment.id,
			status: assessment.status as 'sent' | 'started' | 'completed' | null
		};
	} catch (error) {
		console.error('try catch error Failed to create or find assessment :', error);

		return null;
	}
}

function isValidDemographicsData({
	data,
	schoolId,
	sentBy,
	code
}: {
	data: any;
	schoolId: number;
	sentBy: string;
	code: string;
}) {
	const parseRes = createMixedBagAssessmentAndDemographics.safeParse({
		...data,
		schoolId,
		sentBy,
		code
	});

	if (!parseRes.success) {
		console.log('parseRes error => ', JSON.stringify(parseRes.error.flatten().fieldErrors));
		error(400, { message: JSON.stringify(parseRes.error.flatten().fieldErrors) });
		return false;
	}
	return true;
}
